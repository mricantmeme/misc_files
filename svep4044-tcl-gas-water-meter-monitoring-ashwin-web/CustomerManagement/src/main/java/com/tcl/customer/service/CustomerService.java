/*
 * @category Customer Management
 * @copyright Copyright (C) 2018 Contus. All rights reserved.
 * @license http://www.apache.org/licenses/LICENSE-2.0
 */

package com.tcl.customer.service;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletResponse;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.query.BasicQuery;
import org.springframework.stereotype.Service;
import com.tcl.customer.dto.CustomerDeleteReqDto;
import com.tcl.customer.dto.CustomerRegRequestDto;
import com.tcl.customer.dto.CustomerRegResponseDto;
import com.tcl.customer.dto.CustomerResponseDto;
import com.tcl.customer.dto.CustomerStatusReqDto;
import com.tcl.customer.dto.CustomerUpdateReqDto;
import com.tcl.customer.dto.CustomerUpdateResponseDto;
import com.tcl.customer.dto.CustomerUtilityResponseDto;
import com.tcl.customer.dto.UserRegistrationMailDto;
import com.tcl.customer.exceptionhandler.NoDataFoundException;
import com.tcl.customer.exceptionhandler.UserAlreadyExistException;
import com.tcl.customer.exceptionhandler.UserNotFoundException;
import com.tcl.customer.model.Customer;
import com.tcl.customer.model.User;
import com.tcl.customer.model.Utility;
import com.tcl.customer.repo.CustomerRepo;
import com.tcl.customer.repo.UserRepo;
import com.tcl.customer.repo.UtilityRepo;
import com.tcl.customer.response.ListResponse;
import com.tcl.customer.response.Response;
import com.tcl.customer.util.CustomerConstants;
import com.tcl.customer.util.EmailTemplateType;
import com.tcl.customer.util.Helper;
import com.tcl.customer.util.PasswordDecode;

/*
 * This service contains all the logical functionalities thats implemented in this API
 */
@Service
public class CustomerService {

	/*
	 * dependency injection and object initializtion using Autowired annotation
	 */
	@Autowired
	private ModelMapper modelMapper;

	/*
	 * dependency injection and object initializtion using Autowired annotation
	 */
	@Autowired
	private CustomerRepo customerRepo;

	/*
	 * dependency injection and object initializtion using Autowired annotation
	 */
	@Autowired
	private UserRepo userRepo;

	/*
	 * dependency injection and object initializtion using Autowired annotation
	 */
	@Autowired
	private UtilityRepo utilityRepo;

	/*
	 * dependency injection and object initializtion using Autowired annotation
	 */
	@Autowired
	private MailService mailService;

	@Autowired
	private MongoOperations mongoOperation;

	/*
	 * API for creating a new AMR device. (1). The variables and the fields required
	 * for the API needs to be specified. (2). The base classes(DTO) needed for the
	 * micro-service must be created. (3). Once they're created, the logic for
	 * creating a customer record in the DB must be implemented. Logic: a. The
	 * request for creating a customer must be received from the front end and must
	 * be stored in the request DTO. It should contain fields like device customer
	 * username, customer name, customer utilityId, etc.,
	 * 
	 * b. A unique Id for the customer must be created and is stored with the
	 * customer's details. This unique ID is generated by incrementing the previous
	 * device's ID and prefixing it with a customer constant string.
	 * 
	 * d. A response instance is created and is inserted with details like status of
	 * creation, error code (if any), etc. Then it is sent as a response to the
	 * front end.
	 */

	public Response<CustomerRegResponseDto> createCustomer(CustomerRegRequestDto requestDto) {
		Response<CustomerRegResponseDto> responseDto = new Response<>();
		Optional<User> user = userRepo.findByUserId(requestDto.getUserId());
		if (!user.isPresent())
			throw new UserNotFoundException(CustomerConstants.USER_NOT_FOUND);

		Optional<User> userEmail = userRepo.findByEmailId(requestDto.getCustomerEmailId());
		if (userEmail.isPresent())
			throw new UserAlreadyExistException(CustomerConstants.USER_EMAIL_ID_ALREADY_EXISTS);

		User userUserName = userRepo.findByUserNameContainsIgnoreCase(requestDto.getCustomerUserName().toLowerCase());
		if (userUserName != null)
			throw new UserAlreadyExistException(CustomerConstants.USER_NAME_ALREADY_EXISTS);

		if (!requestDto.getPassword().equals(requestDto.getConfirmPassword())) {
			throw new NoDataFoundException(CustomerConstants.PASSWORD_CONFIRMATION);

		}

		Customer addNewCustomer = addCustomerDetails(requestDto);
		User newUser = addNewUser(requestDto, addNewCustomer);
		CustomerRegResponseDto response = new CustomerRegResponseDto();
		response.setCustomerId(addNewCustomer.getCustomerId());
		response.setUserId(newUser.getUserId());
		responseDto.setData(response);
		responseDto.setMessage(CustomerConstants.CUSTOMER_CREATED_SUCCESSFULLY);
		responseDto.setStatus(HttpServletResponse.SC_OK);
		responseDto.setError(false);
		sendRegistrationEmailNotification(requestDto);
		return responseDto;
	}

	private void sendRegistrationEmailNotification(CustomerRegRequestDto requestDto) {
		UserRegistrationMailDto mailDto = new UserRegistrationMailDto();
		mailDto.setFirstName(requestDto.getCustomerName());
		mailDto.setToAddress(requestDto.getCustomerEmailId());
		mailDto.setUserName(requestDto.getCustomerUserName());
		mailDto.setPassword(requestDto.getConfirmPassword());
		mailService.sendEmail(mailDto, requestDto.getCustomerEmailId(), mailDto.getCcAddress(),
				EmailTemplateType.CUSTOMER_REGISTRATION_EMAIL_TEMPLATE);

	}

	/*
	 * (non-Javadoc)
	 * 
	 * DeviceUpdateRequestDto) This method splits the functionalities of the create
	 * user method. It is used to generate a unique ID for the user and prefix it
	 * with a String that is mentioned in the user constants and saves the method
	 * and then sends a response to the controller which in turn sends a response to
	 * the front end.
	 */
	private User addNewUser(CustomerRegRequestDto requestDto, Customer addNewCustomer) {
		String userId = null;
		Optional<User> getUser = userRepo.findFirstByOrderByCreatedDateDesc();
		if (getUser.isPresent()) {
			if (getUser.get().getUserId().charAt(0) == CustomerConstants.CUSTOMER_USER_STARTING)
				userId = Helper.generateNextUserId(getUser.get().getUserId());
			else
				userId = Helper.generateUniqueUserId(CustomerConstants.CUSTOMER_USER_STARTING);

		} else {
			userId = Helper.generateUniqueUserId(CustomerConstants.CUSTOMER_USER_STARTING);

		}
		requestDto.setRoleId(CustomerConstants.CUSTOMER_ADMIN_ROLE_ID);
		modelMapper.getConfiguration().setAmbiguityIgnored(true);
		User addUser = modelMapper.map(requestDto, User.class);
		String hashOfPassword = PasswordDecode.getHash(requestDto.getCustomerUserName().toLowerCase(), "MD5");
		String passwordHash = PasswordDecode.getHash(requestDto.getConfirmPassword(), hashOfPassword, "MD5");
		addUser.setUserName(requestDto.getCustomerUserName());
		addUser.setFirstName(requestDto.getCustomerName());
		addUser.setLastName(requestDto.getCustomerName());
		addUser.setMiddleName(requestDto.getCustomerName());
		addUser.setUserStatus(requestDto.getCustomerStatus());
		addUser.setUserId(userId);
		addUser.setEmailId(addNewCustomer.getCustomerEmailId());
		addUser.setPassword(passwordHash);
		addUser.setPasswordHash(hashOfPassword);
		addUser.setCustomer(addNewCustomer);
		addUser.setIsActive(true);
		addUser.setCreatedBy(requestDto.getUserId());
		addUser.setCreatedDate(new Date());
		addUser.setModifiedBy(requestDto.getUserId());
		addUser.setModifiedDate(new Date());
		return userRepo.save(addUser);

	}

	/*
	 * (non-Javadoc)
	 * 
	 * DeviceUpdateRequestDto) This method splits the functionalities of the create
	 * customer method. It is used to generate a unique ID for the customer and
	 * prefix it with a String that is mentioned in the device constants and saves
	 * the method and then sends a response to the controller which in turn sends a
	 * response to the front end.
	 */
	private Customer addCustomerDetails(CustomerRegRequestDto requestDto) {
		String customerId = null;

		Optional<Utility> details = utilityRepo.findByUtilityId(requestDto.getCustomerUtilityId());
		if (!details.isPresent())
			throw new NoDataFoundException(CustomerConstants.UTILITY_NOT_FOUND);

		Optional<Customer> getCustomer = customerRepo.findFirstByOrderByModifiedDateDesc();
		if (getCustomer.isPresent()) {
			if (getCustomer.get().getCustomerId().charAt(0) == CustomerConstants.CUSTOMER_STARTING)
				customerId = Helper.generateNextCustomerId(getCustomer.get().getCustomerId(),
						details.get().getUtilityName());
			else
				customerId = Helper.generateUniqueCustomerId(details.get().getUtilityName());

		} else {
			customerId = Helper.generateUniqueCustomerId(details.get().getUtilityName());

		}
		modelMapper.getConfiguration().setAmbiguityIgnored(true);
		Customer addNewCustomer = modelMapper.map(requestDto, Customer.class);
		addNewCustomer.setCustomerId(customerId);
		addNewCustomer.setActive(true);
		addNewCustomer.setCreatedBy(requestDto.getUserId());
		addNewCustomer.setCreatedDate(new Date());
		addNewCustomer.setModifiedBy(requestDto.getUserId());
		addNewCustomer.setModifiedDate(new Date());
		return customerRepo.save(addNewCustomer);
	}

	/*
	 * (1). CustomerId and the update details are received from the request. (2).
	 * The ID is used to verify if any device with the specified ID is present in
	 * the DB. (3). If the customer is present, the customer data get updated. Else
	 * an error (specifying that there is no customer present with that Id) is sent
	 * in the response. (4). Then the status of the update process, with the error
	 * code(if any) is sent in the response to the front end.
	 */
	public Response<CustomerUpdateResponseDto> updateCustomer(CustomerUpdateReqDto requestDto) {
		Response<CustomerUpdateResponseDto> responseDto = new Response<>();
		CustomerUpdateResponseDto response = null;
		Optional<Customer> customer = customerRepo.findByCustomerId(requestDto.getCustomerId());
		if (customer.isPresent()) {
			Customer customerDetail = customer.get();
			customerDetail.setAddress(requestDto.getAddress());
			customerDetail.setBillingType(requestDto.getBillingType());
			customerDetail.setBusinessType(requestDto.getBusinessType());
			customerDetail.setCustomerColourConfig(requestDto.getCustomerColourConfig());
			customerDetail.setCustomerDescription(requestDto.getCustomerDescription());
			customerDetail.setCustomerEmailId(requestDto.getCustomerEmailId());
			customerDetail.setCustomerGroupEmailId(requestDto.getCustomerGroupEmailId());
			customerDetail.setCustomerLogo(requestDto.getCustomerLogo());
			customerDetail.setCustomerMobileNumber(requestDto.getCustomerMobileNumber());
			customerDetail.setCustomerName(requestDto.getCustomerName());
			customerDetail.setCustomerPhoneNumber(requestDto.getCustomerPhoneNumber());
			customerDetail.setCustomerStatus(requestDto.getCustomerStatus());
			customerDetail.setUtilityId(requestDto.getCustomerUtilityId());
			customerDetail.setModifiedBy(requestDto.getCustomerId());
			customerDetail.setModifiedDate(new Date());
			customerRepo.save(customerDetail);
			Optional<User> user = userRepo.findByCustomer(customer.get());
			if (!user.isPresent())
				throw new NoDataFoundException(CustomerConstants.CUSTOMER_NOT_FOUND);
			User userStatus = user.get();
			userStatus.setUserStatus(requestDto.getCustomerStatus());
			userStatus.setModifiedBy(requestDto.getCustomerId());
			userStatus.setModifiedDate(new Date());
			userRepo.save(userStatus);
			response = new CustomerUpdateResponseDto();
			response.setCustomerId(customerDetail.getCustomerId());
			responseDto.setData(response);
			responseDto.setMessage(CustomerConstants.CUSTOMER_UPDATED_SUCCESSFULLY);
			responseDto.setStatus(HttpServletResponse.SC_OK);
			responseDto.setError(false);

		} else {
			responseDto.setStatus(HttpServletResponse.SC_NO_CONTENT);
			responseDto.setError(true);
			responseDto.setMessage(CustomerConstants.CUSTOMER_NOT_FOUND);
		}
		return responseDto;

	}

	/*
	 * API for deleting an Customer. The custoimerID is received from the request
	 * and is used to see if there is any customer present in the DB with the same
	 * ID. If the customer (with the specified ID) is present, the "isActive" status
	 * of the customer is changed to false. Else an error(mentioning that there's no
	 * customer present with the specified ID) is sent in the response. The response
	 * is then filled with details like status, message and error codes and is then
	 * sent.
	 */
	public Response<Boolean> deleteCustomer(CustomerDeleteReqDto requestDto) {
		Response<Boolean> responseDto = new Response<>();

		List<Customer> customer = customerRepo.findByCustomerIdIn(requestDto.getCustomerId());
		if (!customer.isEmpty()) {
			for (Customer customerDetail : customer) {
				customerDetail.setActive(false);
				customerDetail.setModifiedDate(new Date());
			}
			customerRepo.save(customer);
			List<User> user = userRepo.findByCustomerIn(customer);
			if (!user.isEmpty()) {
				for (User userDetail : user) {
					userDetail.setIsActive(false);
					userDetail.setModifiedDate(new Date());
				}
				userRepo.save(user);
			}
			responseDto.setMessage(CustomerConstants.CUSTOMER_DELETED_SUCCESSFULLY);
			responseDto.setStatus(HttpServletResponse.SC_OK);
			responseDto.setError(false);

		} else {
			responseDto.setStatus(HttpServletResponse.SC_NO_CONTENT);
			responseDto.setError(true);
			responseDto.setMessage(CustomerConstants.CUSTOMER_NOT_FOUND);
		}
		return responseDto;

	}

	/*
	 * (non-Javadoc)
	 * 
	 * API for listing the all the customers. Search data along with pagination
	 * details are received from the request param(URL). If the search data is
	 * null/blank/empty, all the customers whose state is "Active" in the DB are
	 * sent in the response. Else the search parameters are filtered and the result
	 * is sent in the response. The response is sent with data such as status,
	 * error, message(in this case "list of customers") and the actual list of
	 * devices are sent to the front end.
	 */
	public ListResponse<List<CustomerResponseDto>> listCustomers(String search, int page, int size) {
		ListResponse<List<CustomerResponseDto>> responseDto = new ListResponse<>();

		List<Customer> customerDetails = null;
		if (search == null || search.isEmpty())
			customerDetails = customerRepo.findByIsActive(true, createPageRequest(page, size));

		else
			customerDetails = customerRepo
					.findByCustomerNameContainsIgnoreCaseOrCustomerDescriptionContainsIgnoreCaseOrCustomerEmailIdContainsIgnoreCaseOrCustomerGroupEmailIdContainsIgnoreCaseOrCustomerMobileNumberContainsIgnoreCaseOrUtilityIdContainsIgnoreCaseAndIsActive(
							search, search, search, search, search, search, true, createPageRequest(page, size));

		if (!customerDetails.isEmpty()) {
			List<CustomerResponseDto> lstEntity = new ArrayList<>();
			customerDetails.forEach(u -> lstEntity.add(convertToCustomerDetailsDto(u)));
			responseDto.setData(lstEntity);
			responseDto.setMessage(CustomerConstants.CUSTOMER_LIST);
			responseDto.setStatus(HttpServletResponse.SC_OK);
			responseDto.setError(false);
			responseDto.setCount(customerDetails.size());
			responseDto.setTotalRecords(getTotalRecords(search));

		} else {
			responseDto.setStatus(HttpServletResponse.SC_NO_CONTENT);
			responseDto.setError(true);
			responseDto.setMessage(CustomerConstants.CUSTOMER_NOT_FOUND);
		}

		return responseDto;
	}

	/*
	 * This method gets the value of the total number of records present in the DB
	 * that is "ACTIVE". If there is any search constrains, it returns the total
	 * number of the the search results.
	 */
	private Integer getTotalRecords(String search) {
		if (search == null || search.isEmpty())
			return customerRepo.findByIsActive(true).size();

		else
			return customerRepo
					.findByCustomerNameContainsIgnoreCaseOrCustomerDescriptionContainsIgnoreCaseOrCustomerEmailIdContainsIgnoreCaseOrCustomerGroupEmailIdContainsIgnoreCaseOrCustomerMobileNumberContainsIgnoreCaseOrUtilityIdContainsIgnoreCaseAndIsActive(
							search, search, search, search, search, search, true)
					.size();

	}

	/*
	 * This method splits the functionalities of the get customer method. It maps
	 * the objects of two different classes and copies the data from one to the
	 * other It helps us to avoid traditional mapping of objects.
	 */
	private CustomerResponseDto convertToCustomerDetailsDto(Customer customer) {
		return modelMapper.map(customer, CustomerResponseDto.class);
	}

	/*
	 * This method is used for pagination of the content that gets generated in the
	 * list device method. Here, the list sorted in descending order and ordered by
	 * ID.
	 */
	private Pageable createPageRequest(int page, int size) {
		return new PageRequest(page, size, new Sort(Sort.Direction.DESC, "_id"));
	}

	/*
	 * (non-Javadoc)
	 * 
	 * This method returns the details of one specific customer. The customer ID is
	 * got from the request and then is used to find that particular customer in the
	 * DB.
	 */
	public Response<CustomerResponseDto> viewCustomers(String customerId) {
		Response<CustomerResponseDto> responseDto = new Response<>();
		Optional<Customer> getCustomer = customerRepo.findByCustomerId(customerId);
		if (!getCustomer.isPresent())
			throw new NoDataFoundException(CustomerConstants.CUSTOMER_NOT_FOUND);
		CustomerResponseDto response = modelMapper.map(getCustomer.get(), CustomerResponseDto.class);
		responseDto.setData(response);
		responseDto.setError(false);
		responseDto.setMessage(CustomerConstants.CUSTOMER_DETAILS);
		responseDto.setStatus(HttpServletResponse.SC_OK);
		return responseDto;
	}

	/*
	 * This method is used to update the status of the customer. The update details
	 * are obtained from the request and the response is returned to the front end.
	 */
	public Response<Boolean> updateCustomerStatus(CustomerStatusReqDto requestDto) {
		Response<Boolean> responseDto = new Response<>();
		Optional<Customer> getCustomer = customerRepo.findByCustomerId(requestDto.getCustomerId());
		if (!getCustomer.isPresent())
			throw new NoDataFoundException(CustomerConstants.CUSTOMER_NOT_FOUND);
		Customer updateStatus = getCustomer.get();
		updateStatus.setCustomerStatus(requestDto.getCustomerStatus());
		updateStatus.setModifiedBy(requestDto.getUserId());
		updateStatus.setModifiedDate(new Date());
		customerRepo.save(updateStatus);
		Optional<User> user = userRepo.findByCustomer(updateStatus);
		if (!user.isPresent())
			throw new NoDataFoundException(CustomerConstants.CUSTOMER_NOT_FOUND);
		User userStatus = user.get();
		userStatus.setUserStatus(requestDto.getCustomerStatus());
		userStatus.setModifiedBy(requestDto.getUserId());
		userStatus.setModifiedDate(new Date());
		userRepo.save(userStatus);
		responseDto.setError(false);
		responseDto.setMessage(CustomerConstants.CUSTOMER_STATUS);
		responseDto.setStatus(HttpServletResponse.SC_OK);
		return responseDto;
	}

	/*
	 * This method returns the utility details of one specific customer. The
	 * customer ID is got from the request and then is used to find that particular
	 * customer in the DB. Then the customers utility ID is binded with the response
	 * and is sent with it.
	 */
	public Response<CustomerUtilityResponseDto> viewCustomerUtilityType(String customerId) {
		Response<CustomerUtilityResponseDto> responseDto = new Response<>();
		Optional<Customer> getCustomer = customerRepo.findByCustomerId(customerId);
		if (!getCustomer.isPresent())
			throw new NoDataFoundException(CustomerConstants.CUSTOMER_NOT_FOUND);
		CustomerUtilityResponseDto response = new CustomerUtilityResponseDto();
		response.setUtilityId(getCustomer.get().getUtilityId());
		responseDto.setData(response);
		responseDto.setError(false);
		responseDto.setMessage(CustomerConstants.CUSTOMER_UTILITY_TYPE);
		responseDto.setStatus(HttpServletResponse.SC_OK);
		return responseDto;
	}


	public ListResponse<List<CustomerResponseDto>> filterListCustomers(List<String> filters, String sortByFieldName,String sortType, Integer page, Integer size) {
		ListResponse<List<CustomerResponseDto>> responseDto=new ListResponse<>();
		List<CustomerResponseDto> lstEntity=new ArrayList<>();

		String customersSearchFields="";
		List<Customer> totalCustomerDetails=null;
		List<CustomerResponseDto> customerDetails=new ArrayList<>();

		BasicQuery executeQuery=null;
		String filter=null;
		String soryBy=null;

		if(filters.size() >0 && sortByFieldName != "" && sortType != "") {
			filter=filters.stream().map(Object::toString).collect(Collectors.joining("},{","{","}"));
			customersSearchFields=CustomerConstants.CUSTOMER_DEFAULT_QUERY;
			soryBy="{"+sortByFieldName+":"+sortType+"}";
			customersSearchFields=String.format(customersSearchFields, filter,soryBy);

		}else if (filters.size() >0 && sortByFieldName == "") {
			filter=filters.stream().map(Object::toString).collect(Collectors.joining("},{","{","}"));
			customersSearchFields=CustomerConstants.CUSTOMER_DEFAULT_FILTER_QUERY;
			customersSearchFields=String.format(customersSearchFields, filter);


		}else if (sortByFieldName != "" && sortType != "") {
			soryBy="{"+sortByFieldName+":"+sortType+"}";
			customersSearchFields=CustomerConstants.CUSTOMER_DEFAULT_SORT_QUERY;
			customersSearchFields=String.format(customersSearchFields, soryBy);
		}else

			customersSearchFields=CustomerConstants.CUSTOMER_DEFAULT_ACTIVE_QUERY;
		executeQuery = new BasicQuery(customersSearchFields);
		totalCustomerDetails = mongoOperation.find(executeQuery, Customer.class);


		if(totalCustomerDetails.isEmpty()) {
				responseDto.setData(lstEntity);
				responseDto.setCount(0);
				responseDto.setError(false);
				responseDto.setMessage(CustomerConstants.CUSTOMER_NOT_FOUND);
				responseDto.setStatus(HttpServletResponse.SC_OK);
				responseDto.setTotalRecords(0);
				return 	responseDto;
		}

		totalCustomerDetails.forEach(u -> lstEntity.add(convertToCustomerDetailsDto(u)));

		if (page == 0)
			page = 1;
		else
			page++;

		Long startNumber = (long) (((size * page) - size) + 1);
		Long endNumber = (long) (size * page);
		if (lstEntity.size() >= 0) {

			int fromIndex = (startNumber.intValue() - 1);
			int toIndex = endNumber.intValue();

			if (lstEntity.size() <= endNumber.intValue()) {
				toIndex = lstEntity.size();
			}

			customerDetails = lstEntity.subList(fromIndex, toIndex);
		}
		customerDetails = customerDetails.stream().collect(Collectors.toList());
		responseDto.setData(customerDetails);
		responseDto.setCount(customerDetails.size());
		responseDto.setTotalRecords(lstEntity.size());
		responseDto.setError(false);
		responseDto.setMessage(CustomerConstants.CUSTOMER_LIST);

		return responseDto;

	}
}